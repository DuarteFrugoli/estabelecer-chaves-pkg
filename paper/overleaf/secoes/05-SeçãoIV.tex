\section{Metodologia Experimental}
\label{sec:metodos}

Esta seção apresenta a metodologia empregada na implementação e validação experimental do sistema de geração de chaves criptográficas em camada física. Descrevem-se o ambiente de desenvolvimento, a modelagem do canal sem fio com correlação espacial, e os sete experimentos sistemáticos conduzidos para avaliar o desempenho, a segurança e a viabilidade prática do sistema proposto em diferentes cenários de operação.

\subsection{Ambiente de Desenvolvimento e Implementação}

As simulações foram implementadas integralmente em Python 3.12, devido à sua flexibilidade e à ampla disponibilidade de bibliotecas científicas voltadas ao processamento numérico e à análise de sinais. As principais dependências incluem \textbf{NumPy}, utilizado para geração de amostras complexas e operações matriciais; \textbf{SciPy}, empregado em funções estatísticas, incluindo a função de Bessel $J_0$ para cálculo de correlação espacial; \textbf{Matplotlib}, destinado à visualização e geração de gráficos de desempenho; \textbf{Galois}, utilizado na implementação de códigos \ac{BCH} aplicados na etapa de reconciliação da informação; \textbf{hashlib}, responsável pela implementação do algoritmo \ac{SHA}-256 empregado na amplificação de privacidade; e \textbf{tqdm}, utilizado para exibição de barras de progresso durante execuções de longa duração.

Todas as simulações foram executadas em ambiente local, em um computador equipado com processador Intel Core i7 de 11ª geração com 16 \textit{threads}, assegurando capacidade computacional adequada para a realização dos experimentos numéricos. O gerenciamento de dependências e dos ambientes virtuais foi realizado por meio do \textit{Poetry}, uma ferramenta moderna para controle e reprodutibilidade de projetos em Python. A estrutura modular do código foi organizada em pacotes independentes: \texttt{canal/} para simulação de canais Rayleigh com correlação espacial e modulação \ac{BPSK}/\ac{QPSK}; \texttt{codigos\_corretores/} para codificação e decodificação \ac{BCH}; \texttt{pilares/} para reconciliação \textit{code-offset} e amplificação de privacidade via \ac{SHA}-256; e \texttt{visualizacao/} para geração de gráficos.

\subsubsection{Trechos de Código Representativos}

Para ilustrar a implementação prática do sistema, apresentam-se três trechos de código representativos das operações centrais: geração de canais correlacionados espacialmente, protocolo de reconciliação \textit{code-offset}, e cálculo da correlação espacial segundo o modelo de Clarke.

A geração de canais correlacionados espacialmente, implementando a relação $h_B = \rho h_A + \sqrt{1-\rho^2} h_{\text{ind}}$, é realizada conforme o Código~\ref{code:canais_correlacionados}:

\begin{lstlisting}[language=Python, caption={Geração de canais Rayleigh correlacionados espacialmente.}, label=code:canais_correlacionados, basicstyle=\small\ttfamily, breaklines=true]
def gerar_canais_correlacionados(rho, n_amostras):
    """Gera canais h_A e h_B correlacionados espacialmente."""
    h_A = (np.random.randn(n_amostras) + 
           1j * np.random.randn(n_amostras)) / np.sqrt(2)
    h_ind = (np.random.randn(n_amostras) + 
             1j * np.random.randn(n_amostras)) / np.sqrt(2)
    h_B = rho * h_A + np.sqrt(1 - rho**2) * h_ind
    return h_A, h_B
\end{lstlisting}

O protocolo \textit{code-offset} para reconciliação de chaves, descrito teoricamente na Seção~II, é implementado conforme o Código~\ref{code:code_offset}:

\begin{lstlisting}[language=Python, caption={Protocolo code-offset para reconciliação BCH.}, label=code:code_offset, basicstyle=\small\ttfamily, breaklines=true]
def reconciliar_code_offset(b_A, b_B, bch):
    """Reconcilia sequencias binarias via code-offset BCH."""
    k = bch.k  # Bits de informacao
    # Bob: gera r, codifica, transmite sindrome
    r = np.random.randint(0, 2, k)
    c = bch.encode(r)
    sindrome = b_B ^ c  # XOR bit a bit
    
    # Alice: recebe sindrome, reconcilia
    c_prime = sindrome ^ b_A
    c_hat = bch.decode(c_prime)
    b_A_rec = sindrome ^ c_hat
    return b_A_rec, b_B
\end{lstlisting}

Finalmente, o cálculo da correlação espacial segundo o modelo de Clarke, utilizando a função de Bessel de primeira espécie de ordem zero $J_0(\cdot)$, é implementado conforme o Código~\ref{code:clarke}:

\begin{lstlisting}[language=Python, caption={Cálculo da correlação espacial via modelo de Clarke.}, label=code:clarke, basicstyle=\small\ttfamily, breaklines=true]
from scipy.special import jv  # Funcao de Bessel

def correlacao_espacial_clarke(distancia, freq_hz):
    """Calcula correlacao espacial rho = J_0(2*pi*d/lambda)."""
    c = 3e8  # Velocidade da luz (m/s)
    lambda_m = c / freq_hz  # Comprimento de onda (m)
    arg = 2 * np.pi * distancia / lambda_m
    rho = jv(0, arg)  # J_0(2*pi*d/lambda)
    return rho
\end{lstlisting}

Esses trechos de código demonstram a simplicidade da implementação e facilitam a reprodutibilidade dos resultados por outros pesquisadores.

\subsection{Modelagem do Canal e Correlação Espacial}

O canal sem fio é modelado como desvanecimento Rayleigh plano, representado por coeficientes complexos $h \sim \mathcal{CN}(0,1)$, cujo módulo segue distribuição Rayleigh e a fase é uniformemente distribuída em $[0,2\pi]$. Esse modelo captura condições de propagação multipercurso sem linha de visada direta (\ac{NLoS}), típicas de ambientes internos e urbanos densos.

No cenário considerado, Alice e Bob recebem sinais \textit{downlink} provenientes de uma mesma estação rádio base, que transmite um sinal de referência $x$. Os sinais recebidos são modelados como
\begin{equation}
y_A = h_A \, x + n_A, \quad y_B = h_B \, x + n_B,
\end{equation}
em que $h_A$ e $h_B$ denotam os coeficientes de canal entre a estação base e cada dispositivo, e $n_A, n_B \sim \mathcal{CN}(0,\sigma^2_n)$ representam ruído \ac{AWGN} independente em cada receptor.

Devido à proximidade espacial entre Alice e Bob, os canais $h_A$ e $h_B$ apresentam correlação estatística significativa, modelada por
\begin{equation}
h_B = \rho \, h_A + \sqrt{1-\rho^2} \, h_{\text{ind}},
\end{equation}
em que $\rho \in [0,1]$ é o coeficiente de correlação espacial e $h_{\text{ind}} \sim \mathcal{CN}(0,1)$ é uma componente independente. O valor de $\rho$ é determinado pela separação física $d$ entre os dispositivos segundo a função de Bessel de ordem zero descrita na Seção~II, sendo $\rho = 0.9$ o valor típico adotado neste trabalho para dispositivos próximos.

A variância do ruído é calculada a partir da \ac{SNR} desejada como $\sigma^2_n = 10^{-\text{SNR}_{\text{dB}}/10}$, permitindo controle preciso das condições do canal nos experimentos. Todas as simulações empregam análise de Monte Carlo com 1000 realizações independentes por configuração, garantindo significância estatística dos resultados.

\subsection{Fluxo de Processamento do Sistema}

O processamento completo do sistema para geração de uma chave compartilhada segue o fluxo:
\begin{enumerate}
    \item Geração dos canais correlacionados espacialmente: $h_A \sim \mathcal{CN}(0,1)$ e $h_B$ correlacionado via modelo de Clarke;
    \item Recepção dos sinais \textit{downlink}: $y_A = h_A x + n_A$ e $y_B = h_B x + n_B$;
    \item Estimação dos coeficientes de canal com erro controlado (tipicamente 10--30\% dependendo do perfil);
    \item Quantização das observações utilizando modulação \ac{BPSK} ($\pm 1$) ou \ac{QPSK} (símbolos $\pm 1 \pm j$), com limiarização adaptativa opcional (\textit{guard-band});
    \item Reconciliação das sequências binárias via protocolo \textit{code-offset} com código \ac{BCH}(127,64,10);
    \item Amplificação de privacidade aplicando \ac{SHA}-256 para obtenção da chave final de 256 bits;
    \item Cálculo das métricas de desempenho: \ac{BMR} antes da reconciliação e \ac{KDR} após reconciliação.
\end{enumerate}

\subsection{Métricas de Desempenho}

O desempenho do sistema é avaliado por meio de duas métricas principais. A \ac{BMR} quantifica a taxa de discordância de bits entre as sequências obtidas por Alice e Bob imediatamente após a quantização, antes da aplicação do protocolo de reconciliação:
\begin{equation}
\text{BMR} = \frac{\text{número de bits diferentes entre } \mathbf{b}_A \text{ e } \mathbf{b}_B}{\text{número total de bits}} \times 100\%.
\end{equation}

O \ac{KDR} mede a taxa de discordância após a reconciliação \ac{BCH}:
\begin{equation}
\text{KDR} = \frac{\text{número de bits diferentes após reconciliação}}{\text{número total de bits}} \times 100\%.
\end{equation}

Idealmente, espera-se \ac{BMR} proporcional à \ac{SNR} do canal e à correlação espacial, e \ac{KDR} $= 0\%$ após reconciliação bem-sucedida, desde que o número de erros não exceda a capacidade de correção do código \ac{BCH} ($t=10$ erros). Para avaliação de segurança, mede-se também a \ac{BER} de um atacante passivo (Eve) localizado a diferentes distâncias, esperando-se \ac{BER} $\approx 50\%$ quando Eve está descorrelacionado espacialmente ($\rho_{\text{espacial}} \approx 0$).

\subsection{Experimentos Conduzidos}

Sete experimentos sistemáticos foram realizados para validação abrangente do sistema proposto, cobrindo aspectos de desempenho, segurança, complexidade computacional e aplicabilidade em cenários práticos de \ac{IoT}.

\subsubsection{Experimento 1: Impacto da Relação Sinal-Ruído}

O primeiro experimento investiga o impacto da \ac{SNR} sobre a \ac{BMR} inicial e o \ac{KDR} após reconciliação. A \ac{SNR} é variada logaritmicamente de $-10$~dB a $30$~dB em 18 pontos, mantendo-se fixos a correlação espacial $\rho = 0.9$, a modulação \ac{BPSK}, e o código \ac{BCH}(127,64,10). O objetivo é identificar o \ac{SNR} mínimo necessário para operação confiável do sistema, caracterizado por \ac{KDR} $= 0\%$ entre Alice e Bob.

\subsubsection{Experimento 2: Comparação entre BPSK e QPSK}

Este experimento compara o desempenho dos esquemas de modulação \ac{BPSK} (1 bit/símbolo) e \ac{QPSK} (2 bits/símbolo) em termos de \ac{BMR} e \ac{KDR}. Mantém-se correlação espacial $\rho = 0.9$ e varia-se a \ac{SNR} conforme o Experimento~1. A modulação \ac{QPSK}, embora ofereça maior eficiência espectral, apresenta maior sensibilidade a ruído e erros de fase, o que pode aumentar ligeiramente o \ac{KDR} em regimes de baixa \ac{SNR}.

\subsubsection{Experimento 3: Variação do Código BCH}

Avalia-se o desempenho de diferentes códigos \ac{BCH} na etapa de reconciliação: \ac{BCH}(7,4,1), \ac{BCH}(15,7,2) e \ac{BCH}(127,64,10). Códigos com maior capacidade de correção ($t$ maior) tendem a reduzir o \ac{KDR} em cenários com maior \ac{BMR} inicial, ao custo de redução na taxa de código ($R = k/n$) e maior complexidade computacional. O experimento identifica o código que oferece melhor compromisso entre robustez e eficiência.

\subsubsection{Experimento 4: Análise de Complexidade Computacional}

Este experimento mede o tempo de execução das principais operações do sistema: codificação e decodificação \ac{BCH}, e aplicação da função hash \ac{SHA}-256. O objetivo é verificar a viabilidade prática do sistema em dispositivos \ac{IoT} com recursos limitados de processamento. Compara-se o tempo de execução para diferentes códigos \ac{BCH}, incluindo \ac{BCH}(127,64) e \ac{BCH}(255,139), avaliando a escalabilidade do sistema.

\subsubsection{Experimento 5: Perfis de Dispositivos IoT}

O quinto experimento valida a aplicabilidade do sistema em cinco perfis representativos de dispositivos \ac{IoT}, cada um caracterizado por parâmetros físicos realistas de mobilidade, frequência de operação e condições de canal. Os perfis incluem: (i)~sensor estático (0~km/h, 870~MHz); (ii)~\textit{wearable}/pessoa andando (5~km/h, 2.4~GHz); (iii)~veículo urbano (60~km/h, 5.9~GHz); (iv)~drone (40~km/h, 2.4~GHz); (v)~dispositivo NB-IoT (10~km/h, 900~MHz).

Para cada perfil, a correlação temporal do canal é calculada via modelo de Jakes, $\rho_{\text{temporal}} = J_0(2\pi f_D \tau)$, onde $f_D$ é o \textit{Doppler spread} e $\tau$ o intervalo de amostragem. Adicionalmente, incorpora-se erro de estimação de canal proporcional às condições de operação (8--30\%), e ajusta-se o parâmetro de \textit{guard-band} para cada perfil visando otimizar o compromisso entre robustez e eficiência. O experimento identifica o \ac{SNR} mínimo operacional para cada cenário.

\subsubsection{Experimento 6: Análise de Segurança contra Espionagem Passiva}

Investiga-se a segurança do sistema contra um atacante passivo (Eve) que observa o canal a partir de posições espaciais e temporais distintas. Duas configurações são avaliadas: (i)~descorrelação espacial, variando a distância lateral de Eve em relação a Alice de 0.1~m a 10~m, com frequência fixa em 2.4~GHz ($\lambda = 12.5$~cm); (ii)~descorrelação temporal, variando o atraso de observação de Eve de 0 a 10~ms.

Para cada configuração, calcula-se a correlação espacial $\rho_{\text{espacial}} = J_0(2\pi d/\lambda)$ e temporal $\rho_{\text{temporal}} = J_0(2\pi f_D \tau)$, e mede-se a \ac{BER} de Eve antes e após reconciliação \ac{BCH}. Espera-se que para distâncias superiores a $\lambda/2$ ($\approx 6.25$~cm), a correlação espacial seja suficientemente baixa para garantir \ac{BER} de Eve próxima a 50\% (equivalente a chute aleatório), validando a segurança do sistema.

\subsubsection{Experimento 7: Impacto do Guard-Band}

O último experimento avalia o impacto da limiarização adaptativa (\textit{guard-band}) sobre a eficiência e segurança do sistema. Varia-se o parâmetro de \textit{guard-band} de 0.0 (sem zona morta) a 1.0 (zona morta ampla, em múltiplos de $\sigma_n$), medindo-se: (i)~\ac{KDR} entre Alice e Bob; (ii)~\ac{BER} de Eve; (iii)~percentual de bits descartados; (iv)~taxa efetiva de geração de chaves em bits por segundo.

O experimento investiga se \textit{guard-band} elevado melhora a segurança contra Eve (aumentando \ac{BER} de Eve) ou se introduz viés estatístico que pode ser explorado pelo atacante. Adicionalmente, quantifica-se o custo em termos de redução da taxa de geração de chaves devido ao descarte de bits próximos ao limiar de decisão.